# 功能性特性

## 自动kill空闲事务

Kill超过一定市场的空闲事务，即使释放资源。

### 适用场景

对于处于开启事务状态的链接（显示使用 begin、start transaction 或者隐式开启事务），如果超过时间内没有下一条语句执行，kill连接。

### 使用说明

通过参数 cdb_kill_idle_trans_timeout控制是否开启该功能，0为不用，非0为启用，与 session 的 wait_timeout 值相比取较小值。

<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>cdb_kill_idle_trans_timeout</td><td>YES</td><td>ulong</td><td>0</td><td>[0,31536000]</td><td>0代表关闭该功能，否则代表会kill掉cdb_kill_idle_trans_timeout秒的空闲事务</td></tr></tbody></table>

## 并行复制

官方MySQL5.6一下的版本在slave节点进行回放，master节点同步binlog时，均为单线程模式，5.6及之后的版本变更为并行模式。但官方的并行是基于database和logical clock，并行粒度太大，导致很多情况下并行效果并不理想。  
腾讯云TXSQL内核针对并行复制进行了优化，支持按table并行，相当于将粒度拆分至表，提升了并行度，从而减少了主从延迟。

### 适用场景

该功能主要针对部分负载能提升slave机重放binlog速度，减少主从的delay。

### 使用说明

MySQL5.6、5.7版本如需按table执行并行复制，在设置参数slave_parallel_workers不为0的前提下，可通过将参数slave_parallel_type设置为新增加的值TABLE来实现，MySQL8.0版本不支持TABLE模式。  
另外information_schema下新增了状态表cdb_slave_thread_status，用于展示状态信息。

* 5.6版本

<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>slave_parallel_type</td><td>YES</td><td>char*</td><td>SCHEMA</td><td>SCHEMA/TABLE</td><td>从机并行复制级别：
SCHEMA 为对象级别复制，不同对象的复制事件可以并行执行。
TABLE 为表级别复制，不同表的复制事件可以并行执行。
</td></tr></tbody></table>

* 5.7版本

<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>slave_parallel_type</td><td>YES</td><td>char*</td><td>LOGICAL_CLOCK</td><td>DATABASE/TABLE/LOGICAL_CLOCK</td><td>从机并行复制级别：
DATABASE 为库级别的复制，不同数据库的复制事件可并行完成。
TABLE 为表级别复制，不同表的复制事件可以并行执行。
LOGICAL_CLOCK 为逻辑时钟级别复制，在主机上属于相同逻辑时钟的事件可并发执行。
</td></tr></tbody></table>

* 8.0版本

<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>slave_parallel_type</td><td>YES</td><td>char*</td><td>LOGICAL_CLOCK</td><td>DATABASE/LOGICAL_CLOCK</td><td>从机并行复制级别：
DATABASE 为库级别的复制，不同数据库的复制事件可并行完成。
LOGICAL_CLOCK 为逻辑时钟级别复制，在主机上属于相同逻辑时钟的事件可并发执行。
</td></tr></tbody></table>

## 动态线程池

线程池（Thread_pool）采用一定数量的工作线程来处理连接请求，通常比较适应与OLTP工作负载的场景。但线程池的不足在于当请求偏向于慢查询时，工作线程阻塞在高时延操作上，难以快速响应新的请求，导致系统吞吐量反而相交传统one-thread-per-connection（Per_thread）模式更低。  
Per_thread模式与Thread_pool模式各有优缺点，系统许哟啊根据业务类型灵活的进行切换。遗憾的是，当前两种模式的切换必须重启服务器才能完成。通常而言，两种模式想换转换的需求都是出现在业务高峰时段，此时强制重启服务器将对业务造成严重影响。  
为了提高Per_thread模式与Thread_pool模式切换的灵活程度，云数据库Mysql提出了线程池动态切换的优化，即在不重启数据库服务器的情况下，动态开启或关闭线程池。

### 适用场景

对性能敏感，需要根据业务类型灵活调整数据库工作模式的业务。

### 性能影响

* pool-of-threads 切换为 one-thread-per-connection 过程本身不会带来query堆积，以及性能影响。
  
* one-thread-per-connection 切换为 pool-of-threads 过程由于之前线程池处于休眠状态，在QPS极高并且有持续高压的情况下，可能存在一定的请求累积，解决方法如下：
  
>1. 方案一：适当增大 thread_pool_oversubscribe，并适当调小 thread_pool_stall_limit，快速激活线程池，待消化完堆积SQL再视情况还原上述修改。
>2. 方案二：出现SQL累积时，短暂暂停或鉴定业务流量几秒钟，等待 pool-of-threads完成激活，再回复持续高压业务流量

### 使用说明

新增 thread_handling_switch_mode 用于控制线程池动态切换功能，可选值及其含义如下：

<table><tbody><tr><td>可选值</td><td>含义</td></tr><tr><td>disabled</td><td>禁止模式动态迁移</td></tr><tr><td>stable</td><td>只有新连接迁移</td></tr><tr><td>fast</td><td>新连接+新请求都迁移，默认模式</td></tr><tr><td>sharp</td><td>kill当前活跃连接，迫使用户重连，达到快速切换的效果</td></tr></tbody></table>

在 <kbd>show threadpool status</kbd> 中新增如下状态：

* connection_moved_from_per_thread 表示从 Per_thread 迁移至 Thread_pool 的 connections 数量。
* connection_moved_to_per_thread 表示从 Thread_pool 迁移至 Per_thread 的 connections 数量。
* events_consumed 表示每个线程池工作线程组消费的 events 总数，当 Thread_pool 迁移至 Per_thread 后，events 总数不在增加。
* average_wait_usercs_in_queue 表示每个 event 平均在 queue 中等待的时间。

在 <kbd>show full processlist</kbd>中新增如下状态：

* Moved_to_per_thread 表示该连接迁移到 Per_thread 的次数。
* Moved_to_thread_pool 表示该连接迁移到 Thread_pool 的次数。

### 相关参数状态说明

线程池相关参数的介绍：
<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>thread_pool_idle_timeout</td><td>Yes</td><td>uint</td><td>60</td><td>[1,UINT_MAX]</span></span></span></td><td>worker线程在没有需要处理的网络事件时，最多等待此时间（单位秒）后销毁</td></tr><tr><td>thread_pool_oversubscribe</td><td>Yes</td><td>uint</td><td>3</td><td>[1,1000]</span></span></span></td><td>在一个工作组中最多允许多少个worker</td></tr><tr><td>thread_pool_size</td><td>Yes</td><td>uint</td><td>当前机器CPU个数</span></span></span></td><td>[1,1000]</span></span></span></td><td>线程组个数</td></tr><tr><td>thread_pool_stall_limit</td><td>Yes</td><td>uint</td><td>500</td><td>[10,UINT_MAX]</td><td>每间隔此时间（单位毫秒）timer线程负责遍历检查一次所有线程组。当线程组没有listener、高低优先级队列非空并且没有新增的IO网络事件时，认为线程组处于stall状态，timer线程负责唤醒或创建新的worker线程来缓解该线程组的压力</td></tr><tr><td>thread_pool_max_threads</td><td>Yes</td><td>uint</td><td>100000</td><td>[1,100000]</span></span></span></td><td>线程池中所有worker线程的总数</td></tr><tr><td>thread_pool_high_prio_mode</td><td>Yes,session</span></span></span></td><td>enum</td><td>transactions</span></span></span></td><td>transactions\statement\none</td><td>高优先级队列工作模式，包括三种：<div>transactions：只有一个已经开启了事务的SQL，并且thread_pool_high_prio_tickets不为0，才会进入到高优先级队列中，每个连接在thread_pool_high_prio_tickets池被放到优先队列中后，会移到普通队列中</div><div>statement：所有连接都被放入高优先级队列中</div><div>none：与statement相反，所有连接都被放入低优先级队列中</div></td></tr><tr><td>thread_pool_high_prio_tickets</td><td>Yes,session</span></span></span></td><td>uint</td><td>UINT_MAX</span></span></span></td><td>[0,UINT_MAX]</span></span></span></td><td>transactions工作模式下，给每个连接授予的tickets大小</td></tr><tr><td>threadpool_workaround_epoll_bug</td><td>Yes</td><td>bool</td><td>false</td><td>true/false</span></span></span></td><td>是否绕过linux2.x中的epollbug，该bug在linux3中修复</td></tr></tbody></table>

<kbd>show threadpool status</kbd>命令展示的相关状态介绍：

<table><tbody><tr><td>状态名</td><td>说明</td></tr><tr><td>groupid</td><td>线程组ID</td></tr><tr><td>connection_count</td><td>线程组用户连接数</td></tr><tr><td>thread_count</td><td>线程组内工作线程数</td></tr><tr><td>havelistener</td><td>线程组当前是否存在listener</td></tr><tr><td>active_thread_count</td><td>线程组内活跃worker数量</td></tr><tr><td>waiting_thread_count</td><td>线程组内等待中的worker数量（调用wait_begin的worker）</td></tr><tr><td>waiting_threads_size</td><td>线程组中无网络事件需要处理，进入休眠期等待被唤醒的worker数量（等待thread_pool_idle_timeout秒后自动销毁）</td></tr><tr><td>queue_size</td><td>线程组普通优先级队列长度</td></tr><tr><td>high_prio_queue_size</td><td>线程组高优先级队列长度</td></tr><tr><td>get_high_prio_queue_num</td><td>线程组内事件从高优先级队列被取走的总次数</td></tr><tr><td>get_normal_queue_num</td><td>线程组内事件从普通优先级队列被取走的总次数</td></tr><tr><td>create_thread_num</td><td>线程组内创建的worker线程总数</td></tr><tr><td>wake_thread_num</td><td>线程组内从waiting_threads队列中唤醒的worker总数</td></tr><tr><td>oversubscribed_num</td><td>线程组内worker发现当前线程组处于oversubscribed状态，并且准备进入休眠的次数</td></tr><tr><td>mysql_cond_timedwait_num</td><td>线程组内worker进入waiting_threads队列的总次数</td></tr><tr><td>check_stall_nolistener</td><td>线程组被timer线程check_stall检查中发现没有listener的总次数</td></tr><tr><td>check_stall_stall</td><td>线程组被timer线程check_stall检查中被判定为stall状态的总次数</td></tr><tr><td>max_req_latency_us</td><td>线程组中用户连接在队列等待的最长时间（单位毫秒）</td></tr><tr><td>conns_timeout_killed</td><td>线程组中用户连接因客户端无新消息时间超过阈值（net_wait_timeout）被killed的总次数</td></tr><tr><td>connections_moved_in</td><td>从其他线程组中迁入该线程组的连接总数</td></tr><tr><td>connections_moved_out</td><td>从该线程组迁出到其他线程组的连接总数</td></tr><tr><td>connections_moved_from_per_thread</td><td>从one-thread-per-connection模式中迁入该线程组的连接总数</td></tr><tr><td>connections_moved_to_per_thread</td><td>从该线程组中迁出到one-thread-per-connection模式的连接总数</td></tr><tr><td>events_consumed</td><td>线程组处理过的events总数</td></tr><tr><td>average_wait_usecs_in_queue</td><td>线程组内所有events在队列中的平均等待时间</td></tr></tbody></table>

## 支持NOWAIT语法

* DDL支持 NO_WAIT 和 WAIT 选项。对于DDL操作，可通过 WAIT 设置等待 MDL LOCK 的秒数，如果在设定时间内为能获取到 MDL LOCK 则直接返回，也可指定 NO_WAIT 选项，未能获取到 MDL LOCK 直接返回。
* SELECT FOR UPDATE 支持 NOWAIT SKIP LOCKED 选项。原有的SELECT FOR UPDATE 逻辑下，如果目标行数据被另一个事务加了锁，则需要等待该事务释放锁，但某些场景，如秒杀，并不希望等待锁，通过 SKIP LOCKED 和 NOWAIT 选项提供一种不需要等待锁的功能。SKIP LOCKED 语句会跳过已经被枷锁的行，这些行不会出现在结果集中；NOWAIT 语句遇到被枷锁的行不会等地啊，同时会报错。
需要注意的是这两种 NO WAIT 使用的关键字是不一样的。

### 支持版本

* 内核版本 MySQL 5.7 20171130 及以上，DDL语句支持 NO_WAIT 和 WAIT 选项。
* 内核版本 MySQL 5.7 20200630 及以上（该功能从 MySQL 8.0 移植，因此8.0版本原生支持），SELECT FOR UPDATE 语句支持 NOWAIT 和 SKIP LOCKED 选项。

### 适用场景

DevAPI/XPlugin 暂不支持 SELECT FOR UPDATE/SHARE 语句中使用 SKIP LOCKED 和 NOWAIT 选项。由于历史原因，DDL 的 NO_WAIT 关键字和 SELECT FOR UPDATE 的 NOWAIT 关键字是两个不同的关键字，需要注意区分。

### 使用说明

```shell
###############session 1###############
MySQL [test]> create table t1(seat_id int, state int, primary key(seat_id)) engine=innodb;
Query OK, 0 rows affected (0.03 sec)

MySQL [test]> INSERT INTO t1 VALUES(1,0), (2,0), (3,0), (4,0);
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0

MySQL [test]> begin;
Query OK, 0 rows affected (0.01 sec)

MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR SHARE;
+---------+-------+
| seat_id | state |
+---------+-------+
|       1 |     0 |
|       2 |     0 |
+---------+-------+
2 rows in set (0.00 sec)

###############session 2###############
MySQL [test]> SET SESSION innodb_lock_wait_timeout=1;
Query OK, 0 rows affected (0.00 sec)
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR UPDATE;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR UPDATE NOWAIT;
ERROR 5010 (HY000): Do not wait for lock.
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR UPDATE SKIP LOCKED;
+---------+-------+
| seat_id | state |
+---------+-------+
|       3 |     0 |
|       4 |     0 |
+---------+-------+
2 rows in set (0.00 sec)

MySQL [test]> SELECT * FROM t1 WHERE seat_id > 0 LIMIT 2 FOR UPDATE NOWAIT;
ERROR 5010 (HY000): Do not wait for lock.
MySQL [test]> SELECT * FROM t1 WHERE seat_id > 0 LIMIT 2 FOR UPDATE SKIP LOCKED;
+---------+-------+
| seat_id | state |
+---------+-------+
|       3 |     0 |
|       4 |     0 |
+---------+-------+
2 rows in set (0.00 sec)

MySQL [test]> commit;
Query OK, 0 rows affected (0.00 sec)
```

SELECT FOR SHARE NOWAIT/SKIP LOCKED

```shell
###############session 1###############
MySQL [test]> begin;
Query OK, 0 rows affected (0.01 sec)

MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR UPDATE;
+---------+-------+
| seat_id | state |
+---------+-------+
|       1 |     0 |
|       2 |     0 |
+---------+-------+
2 rows in set (0.00 sec)

###############session 2###############
MySQL [test]> SET SESSION innodb_lock_wait_timeout=1;
Query OK, 0 rows affected (0.00 sec)

MySQL [test]> begin;
Query OK, 0 rows affected (0.00 sec)

MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 LOCK IN SHARE MODE;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR SHARE;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR SHARE NOWAIT;
ERROR 5010 (HY000): Do not wait for lock.
MySQL [test]> SELECT * FROM t1 WHERE state = 0 LIMIT 2 FOR SHARE SKIP LOCKED;
+---------+-------+
| seat_id | state |
+---------+-------+
|       3 |     0 |
|       4 |     0 |
+---------+-------+
2 rows in set (0.00 sec)

MySQL [test]> commit;
Query OK, 0 rows affected (0.00 sec)
```

DDL语句 NO_WAIT 和 WAIT 选项

```sql
ALTER TABLE `table` [NO_WAIT | WAIT [n]] `command`;
DROP TABLE `table` [NO_WAIT | WAIT [n]];
TRUNCATE TABLE `table` [NO_WAIT | WAIT [n]];
OPTIMIZE TABLE `table` [NO_WAIT | WAIT [n]];
RENAME TABLE `table_src` [NO_WAIT | WAIT [n]] TO `table_dst`;
CREATE INDEX `index` ON `table.columns` [NO_WAIT | WAIT [n]];
CREATE FULLTEXT INDEX `index` ON `table.columns` [NO_WAIT | WAIT [n]];
CREATE SPATIAL INDEX `index` ON `table.columns` [NO_WAIT | WAIT [n]];
DROP INDEX `index` ON `table` [NO_WAIT | WAIT [n]];
```

## 支持 returning

### 功能介绍

在某些适用场景下，需要在 DML 操作后返回刚操作的数据行。实现这个需求一般有两种方法：

* 一是在开启事务后在 DML 语句后紧跟一条 SELECT 语句。
* 二是使用触发器等比较复杂的操作实现。

前者主要会增加一条 SELECT 语句的开销，后者则会令 SQL 的实现变得复杂并且不够灵活（需要创建触发器）。因此，returning 语法的设计针对该场景的优化，通过 DML 语句后增加 returning 关键字可以灵活高效地实现上述需求。

### 适用场景

在目前 MySQL 5.7 20210330 及以上的内核版本中，分别支持：INSERT ... RETURNING、REPLACE ... RETURNING、DELETE ... RETURNING。该语法允许返回所有被 INSERT/REPLACE/DELETE 语句操作过的行（statement 为单位）。同时，RETURNING 也支持在 prepared statements，存储过程中使用。
在目前 MySQL 8.0 20220330 及以上的内核版本中，分别支持：DELETE ... RETURNING、INSERT ... RETURNING、REPLACE ... RETURNING、UPDATE ... RETURNING 语法，可以返回该 statement 所操作的数据行。
在使用该功能时，需要注意以下几点：

1. 在适用 RETURNING 是，DELETE ... RETURNING 语句返回前镜像数据， INSERT/REPLACE ... RETURNING 返回后镜像数据。
2. INSERT/REPLACE 场景下，外层表的列对 returning 中的子查询语句，暂不具有可见性。
3. INSERT/REPLACE 的 RETURNING 语句若需要返回 last_insert_id()，则该 last_insert_id() 的值为该语句执行成功之前的值。若需要获得精确的 last_insert_id() 值，建议使用 RETURNING 直接返回该表的自增列 ID。

### 使用说明

INSERT ... RETURNING

```shell
MySQL [test]> CREATE TABLE `t1` (id1 INT);
Query OK, 0 rows affected (0.04 sec)

MySQL [test]> CREATE TABLE `t2` (id2 INT);
Query OK, 0 rows affected (0.03 sec)

MySQL [test]> INSERT INTO  t2 (id2) values (1);
Query OK, 1 row affected (0.00 sec)

MySQL [test]> INSERT INTO t1 (id1) values (1) returning *, id1 * 2, id1 + 1, id1 * id1 as alias, (select * from t2); 
+------+---------+---------+-------+--------------------+
| id1  | id1 * 2 | id1 + 1 | alias | (select * from t2) |
+------+---------+---------+-------+--------------------+
|    1 |       2 |       2 |     1 |                  1 |
+------+---------+---------+-------+--------------------+
1 row in set (0.01 sec)

MySQL [test]> INSERT INTO t1 (id1) SELECT id2 from t2 returning id1;
+------+
| id1  |
+------+
|    1 |
+------+
1 row in set (0.01 sec)
```

REPLACE ... RETURNING

```shell
MySQL [test]> CREATE TABLE t1(id1 INT PRIMARY KEY, val1 VARCHAR(1));
Query OK, 0 rows affected (0.04 sec)

MySQL [test]> CREATE TABLE t2(id2 INT PRIMARY KEY, val2 VARCHAR(1));
Query OK, 0 rows affected (0.03 sec)

MySQL [test]> INSERT INTO t2 VALUES (1,'a'),(2,'b'),(3,'c');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

MySQL [test]> REPLACE INTO t1 (id1, val1) VALUES (1, 'a');
Query OK, 1 row affected (0.00 sec)

MySQL [test]> REPLACE INTO t1 (id1, val1) VALUES (1, 'b') RETURNING *;
+-----+------+
| id1 | val1 |
+-----+------+
|   1 | b    |
+-----+------+
1 row in set (0.01 sec)
```

DELETE ... RETURNING

```shell
MySQL [test]> CREATE TABLE t1 (a int, b varchar(32));
Query OK, 0 rows affected (0.04 sec)

MySQL [test]> INSERT INTO t1 VALUES
    ->   (7,'ggggggg'), (1,'a'), (3,'ccc'),
    ->   (4,'dddd'), (1,'A'), (2,'BB'), (4,'DDDD'),
    ->   (5,'EEEEE'), (7,'GGGGGGG'), (2,'bb');
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

MySQL [test]> DELETE FROM t1 WHERE a=2 RETURNING *;
+------+------+
| a    | b    |
+------+------+
|    2 | BB   |
|    2 | bb   |
+------+------+
2 rows in set (0.01 sec)

MySQL [test]> DELETE FROM t1 RETURNING *;
+------+---------+
| a    | b       |
+------+---------+
|    7 | ggggggg |
|    1 | a       |
|    3 | ccc     |
|    4 | dddd    |
|    1 | A       |
|    4 | DDDD    |
|    5 | EEEEE   |
|    7 | GGGGGGG |
+------+---------+
8 rows in set (0.01 sec)
```

存储过程

```shell
MySQL [test]> CREATE TABLE `t` (id INT);
Query OK, 0 rows affected (0.03 sec)

MySQL [test]> delimiter $$
MySQL [test]> CREATE PROCEDURE test(in param INT)
    -> BEGIN
    ->     INSERT INTO t (id) values (param) returning *;
    -> END$$
Query OK, 0 rows affected (0.00 sec)
MySQL [test]> delimiter ;

MySQL [test]> CALL test(100);
+------+
| id   |
+------+
|  100 |
+------+
1 row in set (0.01 sec)

Query OK, 0 rows affected (0.01 sec)
```

## 列压缩

### 功能介绍

当前有针对行格式的压缩和针对数据页面的压缩，但是这两种压缩方式在处理一个表中的某些大字段和其他很多小字段，同时对小字段的读写很频繁，对大字段访问不频繁的情形中，它在读写访问时都会造成很多不必要的计算资源的浪费。
列压缩功能可以压缩那些访问不频繁的大字段而不压缩那些访问频繁的小字段，此时不仅能够减少整行字段的存储空间，而且可以提高读写访问的效率。
例如，一张员工表：<kbd>create table employee(id int, age int, gender boolean, other varchar(1000) primary key (id))</kbd>，当对 <kbd>id,age,gender</kbd> 小字段访问比较频繁，而对 other 大字段的访问频率比较低时，可以将 <kbd>other</kbd> 列创建为压缩列。一般情况下，只有对 <kbd>other</kbd> 的读写才会触发对该列的压缩和解压，对其他列的访问并不会触发该列的压缩和解压。由此进一步降低了行数据存储的大小，使得对访问频繁的小字段能够实现更快访问，对访问频率比较低的大字段的存储空间能够实现进一步降低。

### 适用场景

表中有某些大字段和其他很多小字段，同时对小字段的读写很频繁，对大字段访问不频繁的情形中，可以将大字段设置为压缩列。

### 使用说明

#### 支持的数据类型

1. **BLOB**（包含 **TINYBLOB**、**MEDIUMBLOB**、**LONGBLOB**）
2. **TEXT**（包含 **TINYTEXT**、**MEDIUMTEXT**、**LONGTEXT**）
3. **VARCHAR**
4. **VARBINARY**

#### 支持的DDL语法类型

相对官方的建表语句，其中**column_definition**的**COLUMN_FORMAT**定义有所变动，同时列压缩只支持Innodb存储引擎类型的表。

```shell
      column_definition:
        data_type [NOT NULL | NULL] [DEFAULT default_value]
          [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
          [COMMENT 'string']
          [COLLATE collation_name]
          [COLUMN_FORMAT {FIXED|DYNAMIC|DEFAULT}|COMPRESSED=[zlib]]  # COMPRESSED 压缩列关键字
          [STORAGE {DISK|MEMORY}]
          [reference_definition]
```

一个简单的示例如下：

```sql
CREATE TABLE t1(
  id INT PRIMARY KEY,
  b BLOB COMPRESSED
);
```

此时省略了压缩算法，默认选择**zlib**压缩算法，也可以先hi指定压缩算法关键字，目前只支持**zlib**压缩算法。

```sql
CREATE TABLE t1(
  id INT PRIMARY KEY,
  b BLOB COMPRESSED=zlib
);
```

支持的DDL语法总结如下：

**create table 方面**：
<table><tbody><tr><td>DDL</td><td>是否继承压缩属性</td></tr><tr><td>CREATE TABLE t2 LIKE t1;</td><td>Y</td></tr><tr><td>CREATE TABLE t2 SELECT * FROM t1;</td><td>Y</td></tr><tr><td>CREATE TABLE t2(a BLOB) SELECT * FROM t1;</td><td>N</td></tr></tbody></table>

**alter table 方面**:
<table><tbody><tr><td>DDL</td><td>描述</td></tr><tr><td>ALTER TABLE ti MODIFY COLUMN a BLOB;</td><td>将压缩列变为非压缩</td></tr><tr><td>ALTER TABLE t1 MODIFY COLUMN a BLOB COMPRESSED;</td><td>将非压缩变为压缩</td></tr></tbody></table>

### 新增变量说明

<table><tbody><tr><td>参数名</td><td>动态</td><td>类型</td><td>默认</td><td>参数值范围</td><td>说明</td></tr><tr><td>innodb_column_compression_zlib_wrap</td><td>Yes</td><td>bool</td><td>TRUE</td><td>true/false</td><td>如果打开，将生成数据的zlib头和zlib尾并做adler32校验</td></tr><tr><td>innodb_column_compression_zlib_strategy</td><td>Yes</td><td>Integer</td><td>0</td><td>[0,4]</td><td>列压缩使用的压缩策略，最小值为：0，最大值为4，0-4分别和zlib中的压缩策略Z_DEFAULT_STRATEGY、Z_FILTERED、Z_HUFFMAN_ONLY、Z_RLE、Z_FIXED一一对应。一般来说，Z_DEFAULT_STRATEGY对于文本数据常是最佳的，Z_RLE对于图像数据来说是最佳的</td></tr><tr><td>innodb_column_compression_zlib_level</td><td>Yes</td><td>Integer</td><td>6</td><td>[0,9]</td><td>列压缩使用的压缩级别，最小值：0，最大值：9，0代表不压缩，该值越大代表压缩后的数据越小，但压缩时间也越长</td></tr><tr><td>innodb_column_compression_threshold</td><td>Yes</td><td>Integer</td><td>256</td><td>[0,0xffffffff]</td><td>列压缩使用的压缩阈，最小值为：1，最大值为：0xffffffff，单位：字节。只有长度大于或等于该值数据才会被压缩，否则原数据保持不变，只是添加压缩头</td></tr><tr><td>innodb_column_compression_pct</td><td>Yes</td><td>Integer</td><td>100</td><td>[1,100]</td><td>列压缩使用的压缩率，最小值：1，最大值：100，单位：百分比。只有<b>压缩后数据大小/压缩前数据大小</b></span></span><spandata-slate-node="text"><spandata-slate-string="true">低于该值时，数据才会被压缩，否则原数据保持不变，只是添加压缩头</td></tr></tbody></table>

### 新增状态说明

<table><tbody><tr><td>名称</td><td>类型</td><td>说明</td></tr><tr><td><code>Innodb_column_compressed</code></td><td>Integer</td><td>列压缩的压缩次数，包括非压缩格式和压缩格式两种状态的压缩</td></tr><tr><td><code>Innodb_column_decompressed</code></td><td>Integer</td><td>列压缩的解压次数，包括非压缩格式和压缩格式两种状态的解压缩</td></tr></tbody></table>

### 新增错误说明

<table><tbody><tr><td>名称</td><td>范围</td><td>说明</td></tr><tr><td><code>Compressedcolumn'%-.192s'can'tbeusedinkeyspecification</code></td><td>指定压缩的列名</td><td>不能对有索引的列指定压缩属性</td></tr><tr><td><code>Unknowncompressionmethod:%s"</code></td><td>在DDL语句中指定的压缩算法名</td><td>在<code>createtable</code>或者<code>altertable</code>时指定<code>zlib</code>之外非法的压缩算法</td></tr><tr><td><code>Compressedcolumn'%-.192s'can'tbeusedincolumnformatspecification</code></td><td>指定压缩的列名</td><td>在同一个列中，已经指定<code>COLUMN_FORMAT</code>属性就不能再指定压缩属性，其中<code>COLUMN_FORMAT</code>只在NDB中被使用</td></tr><tr><td><code>Altertable...discard/importtablespacenotsupportcolumncompression</code></td><td>\</td><td>带有列压缩的表不能执行<code>Altertable...discard/importtablespace</code>语句</td></tr></tbody></table>

### 性能

整体性能分为 DDL 和 DML 两方面：
DDL 方面，使用 sysbench 进行测试：

* 列压缩对 COPY 算法的 DDL 有较大的性能影响，压缩后性能表现比之前慢7倍 - 8倍。
* 对于 inplace 的影响则取决于压缩后的数据量大小，如果采用压缩后，整体数据大小有降低，那么 DDL 的性能是有提升；反之，性能会有一定的降幅。
* 对于 instant 来说，列压缩对该类型的 DDL 基本没有影响。
DML 方面：考虑最常见的压缩情形（压缩比1:1.8），此时有8个列的表，表中有一个大的 varchar 类型的列，其插入数据长度在1 - 6000内均匀随机，插入的字符在0 - 9 、a - b内随机，其他几个列数据类型为 char(60) 或 int 类型。此时其对非压缩列插入、删除和查询都有10%以内的提升，但对于非压缩列的更新则有10%以内的下降，对于压缩列的更新则有15%以内的性能跌幅。这是因为在更新过程中，MySQL 会先读出该行的值然后再写入该行更新之后的值，整个更新过程会触发一次解压和压缩而插入和查询只会进行一次压缩或者解压。

### 注意事项

1. 逻辑导出方面，逻辑导出时 create table 还是会附有 Compressed 相关的关键字。因此导入时在云数据库 MySQL 内部是支持的。其他 MySQL 分支以及官方版本：
官方版本号小于5.7.18，可以直接导入。
官方版本号大于或等于5.7.18，需要在逻辑导出之后，去掉压缩关键字。
2. DTS 导出其他云或是用户时，在 binlog 同步过程中可能会出现不兼容的问题，可以跳过带压缩关键字的 DDL 语句。
